package com.webcommander.plugin.variation.controllers

import com.webcommander.AutoGeneratedPage
import com.webcommander.AutoPageContent
import com.webcommander.constants.DomainConstants
import com.webcommander.constants.NamedConstants
import com.webcommander.models.ProductData
import com.webcommander.plugin.variation.ProductVariation
import com.webcommander.plugin.variation.VariationService
import com.webcommander.util.AppUtil
import com.webcommander.webcommerce.Product
import com.webcommander.webcommerce.ProductService
import com.webcommander.widget.Widget
import grails.converters.JSON

public class VariationController {
    VariationService variationService
    ProductService productService

    def loadPriceStockImage() {
        Product product = Product.get(params.productId)
        ProductData data = productService.getProductData(product, params['config'])
        String name = data.name.encodeAsBMHTML()
        def imageSize = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.PRODUCT_IMAGE, "size")[NamedConstants.PRODUCT_IMAGE_SETTINGS.THUMBNAIL]
        String image = data.getImageLink(imageSize)
        String currencySymbol = session.currency?.symbol ?: AppUtil.baseCurrency.symbol
        String vString = variationService.getVariationIdentifier(ProductVariation.get(data.attrs.selectedVariation));
        if(data.isAvailable) {
            Map spin = [:]
            if(data.isInventoryEnabled) {
                spin."min" = data.minOrderQuantity ?: 1
                spin."max" = data.maxOrderQuantity ?: data.availableStock
                spin."step" = 1
            }
            render([status: "success", name: name, vString: vString, sku: data.sku, stock: data.availableStock,
                    image: image, price: data.priceToDisplay.toCurrency().toPrice(),
                    currency: currencySymbol,
                    basePrice: data.isOnSale ? data.salePrice : data.basePrice,
                    spin: spin,
                    quantity: data.minOrderQuantity,
                    cartPageDisplayTotal: (data.priceToDisplay * data.minOrderQuantity).toCurrency().toPrice()
            ] as JSON)
        } else {
            render([status: "success", name: name, vString: vString, sku: data.sku, stock: data.availableStock, image: image, msg: g.message(code: "product.not.available"), currency: currencySymbol] as JSON)
        }
    }

    def loadVariationDataInProductList() {
        Boolean forAdmin = params.adminView.toBoolean(false) && session.admin
        Product product = productService.getProductIfAvailable(params.long("productId"), [forAdmin: forAdmin])
        Map configOptions = params['config']
        def config
        if (!product) {
            render([status: "error", message: message(code: "selected.product.not.available")] as JSON)
            return
        }
        if(params['productScope'].equals("category")){
            config = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CATEGORY_PAGE)
            config["display-type"] = NamedConstants.PRODUCT_WIDGET_VIEW.IMAGE
        }
        else {
            config = JSON.parse(Widget.get(params.long('productScope')).params)
        }
        config['is_price_restricted'] = product.isPurchaseRestricted
        config['is_purchase_restricted'] = config['is_price_restricted'] || product.isPurchaseRestricted
        if (!forAdmin && product.availableFor != DomainConstants.PRODUCT_AVAILABLE_FOR.EVERYONE) {
            if (session.customer) {
                if (product.availableFor != DomainConstants.PRODUCT_AVAILABLE_FOR.CUSTOMER) {
                    if (!product.availableToCustomers.id.contains(session.customer) &&!product.availableToCustomerGroups.customers.unique().id.contains(session.customer)) {
                        render([status: "error", message: message(code: "selected.product.not.available")] as JSON)
                        return
                    }
                }
            } else {
                render([status: "error", message: message(code: "selected.product.not.available")] as JSON)
                return
            }
        }
        def imageSize = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.PRODUCT_IMAGE, "size")[NamedConstants.PRODUCT_IMAGE_SETTINGS.GRIDVIEW]
        ProductData productData = productService.getProductData(product, configOptions)
        String html = g.render(template: "/site/singleProductImageView", model: [product: productData, config: config, imageSize: imageSize])
        render([status: "success", html: html] as JSON)
    }

    def loadVariationForProductShortView() {
        Product product = Product.get(params.productId)
        ProductData data = productService.getProductData(product, params['config'])
        def eCommerceConfigs = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.E_COMMERCE)
        AutoGeneratedPage page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.PRODUCT_PAGE)
        AutoPageContent pageContent = AutoPageContent.createCriteria().get {
            eq("belong.id", page.id)
        };
        render(view: "/site/product/${params.viewType == "details"? "productDetailsInfo" : "productShortInfo"}", model: [productData: data, product: product, config: eCommerceConfigs, enableDescription: params.enableDescription, pageContent: pageContent])
    }

    def loadOrderVariationPopup() {
        Product product = Product.get(params.id)
        ProductData data = productService.getProductData(product, [:])
        def eCommerceConfigs = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.E_COMMERCE)
        String vString = variationService.getVariationIdentifier(ProductVariation.get(data.attrs.selectedVariation));
        def variationInfo = [
            name: data.name.encodeAsBMHTML()
        ]
        render(view: "/plugins/variation/admin/orderVariation", model: [productData: data, vString: vString, product: product, config: eCommerceConfigs, vInfo: variationInfo])
    }
}