package com.webcommander.plugin.nab_payment_gateway

import com.webcommander.ApplicationTagLib
import com.webcommander.AutoGeneratedPage
import com.webcommander.config.StoreDetail
import com.webcommander.constants.DomainConstants
import com.webcommander.manager.CartManager
import com.webcommander.models.AddressData
import com.webcommander.models.CardInfo
import com.webcommander.models.Cart
import com.webcommander.models.PaymentInfo
import com.webcommander.throwables.ApplicationRuntimeException
import com.webcommander.throwables.PaymentGatewayException
import com.webcommander.util.AppUtil
import com.webcommander.util.HttpUtil
import com.webcommander.util.StringUtil
import com.webcommander.webcommerce.Currency
import com.webcommander.webcommerce.PaymentGatewayMeta
import grails.gorm.transactions.Transactional
import grails.util.Holders
import groovy.xml.MarkupBuilder

@Transactional
class NabService {
    static ApplicationTagLib _app
    static getApp() {
        if(!_app) {
            return _app = Holders.grailsApplication.mainContext.getBean(ApplicationTagLib)
        }
        return _app
    }

    PaymentInfo resolveInfo(Map params) {
        PaymentInfo info = new PaymentInfo()
        info.amount = params.payment_amount.toDouble()
        info.paymentRef = params.payment_id.toLong()
        info.payerInfo = "Card Type: ${params.card_type}"
        info.gatewayResponse = params.response_text
        info.success = true
        info.trackInfo = "Bank Authorisation: ${params.bank_reference}  \nReceipt Number: ${params.payment_number}"
        return info
    }

    public Map processNetPayment(Map configMap, AddressData billingAddress, Cart cart) {
        boolean isLive = false
        if(configMap["mode"] == "live") {
            isLive = true
        }
        Currency currency = AppUtil.baseCurrency
        if(currency.code != "AUD") {
            throw new ApplicationRuntimeException("could.not.contact.payment.provider.sorry.inconvenience")
        }
        AutoGeneratedPage page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.PAYMENT_SUCCESS_PAGE)
        String successScheme = page.isHttps ? "https" : "http"
        String total = (cart.tagged.payable + cart.tagged.surcharge).toCurrency().toPrice()
        String reference = "Order#${cart.orderId}"
        Map models = [
            vendor_name: configMap["merchantId"],
            payment_alert: StoreDetail.first().address.email,
            Address: billingAddress.addressLine1,
            Country: billingAddress.countryName,
            State: billingAddress.stateName,
            Postcode: billingAddress.postCode,
            information_fields: "Address,Country,State,Postcode",
            payment_reference: reference,
            receipt_address: billingAddress.email,
            return_link_url: app.baseUrl(scheme: successScheme) + "nab/paymentReturn?payment_id=${cart.tagged.payment.id}&payment_amount=&payment_number=&response_code=&response_text=&bank_reference=&card_type=",
            return_link_text: app.message(code: 'continue'),
            reply_link_url: app.baseUrl(scheme: "https")  + "nab/paymentNotify?payment_id=${cart.tagged.payment.id}&payment_amount=&payment_number=&response_code=&response_text=&bank_reference=&card_type=",
            (reference): total
        ]
        String requestUrl = isLive ? "https://transact.nab.com.au/live/hpp/payment" : "https://transact.nab.com.au/test/hpp/payment"
        return [models: models, requestUrl: requestUrl]
    }

    private TransactionResponse parseDirectXMLResult(String resultXML) {
        TransactionResponse result = new TransactionResponse()
        XmlParser parser = new XmlParser()
        Node node = parser.parse(new StringReader(resultXML))
        result.messageID = node.MessageInfo.messageID.text()
        result.merchantID = node.MerchantInfo.merchantID.text()
        result.statusCode = node.Status.statusCode.text()
        result.statusDescription = node.Status.statusDescription.text()
        def txn = node.Payment.TxnList.Txn
        if(txn) {
            result.amount = txn.amount.text().toDouble()
            result.purchaseOrderNo = txn.purchaseOrderNo.text().toInteger()
            result.approved = txn.approved.text().toBoolean()
            result.responseCode = txn.responseCode.text()
            result.responseText = txn.responseText.text()
            result.txnID = txn.txnID.text()
        }
        return result
    }

    PaymentInfo processApiPayment(CardInfo cardInfo, Double totalAmount, Long orderId, Long paymentId) {
        def configs = PaymentGatewayMeta.findAllByFieldFor(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.NAB)
        Map configMap = [:]
        configs.each {
            configMap[it.name] = it.value
        }
        boolean isLive = false
        if(configMap["mode"] == "live") {
            isLive = true
        }

        StringWriter writer = new StringWriter()
        MarkupBuilder xml = new MarkupBuilder(writer)
        xml.NABTransactMessage {
            MessageInfo {
                messageID(StringUtil.uuid)
                timeoutValue(80)
                apiVersion("xml-4.2")
            }
            MerchantInfo {
                merchantID(configMap["merchantId"])
                password(configMap["transaction_password"])

            }
            RequestType("Payment")
            Payment {
                TxnList(count: "1") {
                    Txn(ID: "1") {
                        txnType(0)
                        txnSource(23)
                        amount(Math.round(totalAmount * 100).toString())
                        currency("AUD")
                        purchaseOrderNo(orderId)
                        CreditCardInfo {
                            cardNumber(cardInfo.cardNumber)
                            cvv(cardInfo.cvv)
                            expiryDate(cardInfo.expiryMonth + "/" + cardInfo.expiryYear)
                        }
                    }
                }
            }
        }
        String url = isLive ? "https://transact.nab.com.au/live/xmlapi/payment" : "https://transact.nab.com.au/test/xmlapi/payment"
        String truncatedCardNo = cardInfo.cardNumber.substring(0, 4) + "...." + cardInfo.cardNumber.substring(cardInfo.cardNumber.length() - 4)
        Map logConf = [
                loggerName: "NABLogger",
                replaces: [(cardInfo.cardNumber): truncatedCardNo]
        ]
        String response = HttpUtil.doPostRequest(url, writer.toString(), [:], true, logConf)
        TransactionResponse result = parseDirectXMLResult(response)
        PaymentInfo info = new PaymentInfo()
        info.amount = totalAmount
        info.trackInfo = "" + result.txnID
        info.gatewayResponse = result.responseText
        info.success = result.approved
        info.payerInfo = AppUtil.loggedCustomer ? "Customer#" +  AppUtil.loggedCustomer :"Guest Customer" + " (" + truncatedCardNo + ")"
        info.paymentRef = paymentId
        if(!result.approved) {
            String errorMessage = result.responseText ?: "could.not.process.payment.contact.with.vendor"
            throw new PaymentGatewayException(errorMessage, [], info)
        }
        return info
    }

    PaymentInfo processApiPayment(Map params) {
        def session = AppUtil.session
        Cart cart = CartManager.getCart(session.id, true)
        CardInfo cardInfo = new CardInfo(params.EPS_CARDNUMBER, params.EPS_CCV, params.EPS_EXPIRYMONTH,params.EPS_EXPIRYYEAR)
        return processApiPayment(cardInfo, cart.tagged.payable + cart.tagged.surcharge, cart.orderId, cart.tagged["payment"].id)
    }
}
