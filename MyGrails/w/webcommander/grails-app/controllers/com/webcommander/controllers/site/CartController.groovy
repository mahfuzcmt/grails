package com.webcommander.controllers.site

import com.webcommander.authentication.annotations.AutoGeneratedPage
import com.webcommander.config.StoreProductAssoc
import com.webcommander.constants.DomainConstants
import com.webcommander.design.WidgetService
import com.webcommander.events.AppEventManager
import com.webcommander.manager.CartManager
import com.webcommander.manager.HookManager
import com.webcommander.models.Cart
import com.webcommander.models.CartItem
import com.webcommander.models.ProductData
import com.webcommander.throwables.CartManagerException
import com.webcommander.util.AppUtil
import com.webcommander.util.TemplateMatcher
import com.webcommander.webcommerce.Product
import com.webcommander.webcommerce.ProductService
import com.webcommander.widget.Widget
import grails.converters.JSON

class CartController {

    WidgetService widgetService
    ProductService productService

    def widget() {
        Widget widget = Widget.get(params.id);
        render(text: "") //render must be called, otherwise it will be 404
        widgetService.renderCartWidget(widget, response.writer)
    }

    def remove() {
        CartManager.removeFromCart(session.id, params.long("itemId") ?: 0);
        redirect(controller: "cart", action: "details");
    }

    def empty() {
        CartManager.removeCart(session.id);
        redirect(controller: "cart", action: "details");
    }

    def add() {
        AppEventManager.fire("before-add-to-cart", [params])
        Boolean success;
        String error;
        List errorArgs;
        CartItem cartData;
        Long productId = params.long("productId")
        Integer quantity = params.int("quantity")
        Product product = Product.get(productId)
        ProductData productData = productService.getProductData(product, params.config)
        boolean requiresCombination = false
        if(productData.isCombined && productData.isCombinationQuantityFlexible) {
            requiresCombination = !params.included
        }
        def blockModel = HookManager.hook("productCartAdd", [blocks: []], productData, product, params)

        boolean isMiltiStoreEnabled = false
        def associatedWithMultipleStore = StoreProductAssoc.findAllByProduct(product)
        if (associatedWithMultipleStore.size() && (AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.ADMINISTRATION, "enable_multi_model") == "true") && !params.storeId) {
            isMiltiStoreEnabled = true
        }

        String popupTitle
        if (requiresCombination || blockModel.blocks.size() || isMiltiStoreEnabled) {
            if(params.popupTitle) {
                popupTitle = params.popupTitle
            }
            else if((requiresCombination ? 1 : 0) + blockModel.blocks.size() > 1) {
                popupTitle = "information.required"
            } else if(requiresCombination) {
                popupTitle = "choose.quantity.included.products"
            } else {
                popupTitle = "choose.options"
            }
            Map model = [popupTitle: popupTitle, product: product, productData: productData, quantity: quantity, requiresCombination: requiresCombination, associatedWithMultipleStore: associatedWithMultipleStore]
            if(requiresCombination) {
                model.includedProducts = productService.getIncludedProducts([id: product.id])
            }
            blockModel.blocks.each {
                if(it.requiresKey) {
                    model << [(it.requiresKey): true]
                }
                if(it.model) {
                    model << it.model
                }
            }
            params.remove("controller")
            params.remove("action")
            model.quantity = model.quantity ?: model.productData.supportedMinOrderQuantity
            def html = g.include(view: "/site/incompleteDataCartPopup.gsp", model: model)
            render([status: "incomplete-info", html: html.toString()] as JSON)
            return;
        }
        quantity = quantity ?: productData.supportedMinOrderQuantity
        Closure repeatAdd
        String warning
        Integer added
        repeatAdd = { _quantity ->
            try {
                cartData = CartManager.addToCart(session.id, productData, _quantity, params);
                success = true;
                added = _quantity
            } catch(CartManagerException ex) {
                error = ex.message;
                if(error == "ADD_AVAILABLE") {
                    Integer addedQuantity = CartManager.getAddedQuantity(session.id, productData, params)
                    String message = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.E_COMMERCE, "add_available_message");
                    error = null
                    TemplateMatcher engine = new TemplateMatcher("%", "%")
                    Integer remainingToAdd = ex.messageArgs[0] - addedQuantity
                    Map replacerMap = [
                        requested_quantity: quantity,
                        available_quantity: remainingToAdd
                    ]
                    message = site.message(code: message)
                    warning = engine.replace(message, replacerMap)
                    if(remainingToAdd == 0) {
                        cartData = CartManager.getCartItem(productData, params)
                        success = true;
                        added = 0
                    } else {
                        repeatAdd remainingToAdd
                    }
                } else {
                    success = false;
                    cartData = new CartItem(ex.product, _quantity)
                    errorArgs = ex.messageArgs
                }
            }
        }
        repeatAdd quantity
        Cart cart = CartManager.getCart(session.id);
        if(error) {
            error = site.message(code: error)
            if(errorArgs) {
                TemplateMatcher engine = new TemplateMatcher("%", "%")
                Map replacerMap = [
                    requested_quantity: errorArgs[0],
                    multiple_of_quantity: errorArgs[0],
                    maximum_quantity: errorArgs[0],
                    minimum_quantity: errorArgs[0]
                ]
                error = engine.replace(error, replacerMap)
            }
        }
        def html = g.include(view: "/site/addToCartPopup.gsp", model: [success: success, cartdata: cartData, quantity: success ? added : quantity, warningMessage: warning, errorMessage: error, cart: cart, totalItem: cart ? cart.cartItemList.size() : 0])
        render([status: "added", html: html.toString()] as JSON)
    }

    @AutoGeneratedPage("cart")
    def details() {
        def cart = CartManager.getCart(session.id);
        AppEventManager.fire("before-cart-details-load", [params, cart])
        def eCommerceConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.E_COMMERCE)
        String continueShoppingUrl = null
        if (eCommerceConfig.continue_shopping_target == "previous") {
            continueShoppingUrl = request.getHeader("referer");
            if(continueShoppingUrl && continueShoppingUrl.contains("cart")) {
                continueShoppingUrl = session.lastCartReferer ?: app.relativeBaseUrl() + AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, 'landing_page')
            } else if(!continueShoppingUrl) {
                continueShoppingUrl = app.relativeBaseUrl() + AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, 'landing_page')
            } else {
                session.lastCartReferer = continueShoppingUrl
            }
        } else if(eCommerceConfig.continue_shopping_target == "home") {
            continueShoppingUrl = app.relativeBaseUrl() + AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, 'landing_page')
        } else {
            continueShoppingUrl = app.relativeBaseUrl() + eCommerceConfig.continue_shopping_specified_target
        }
        def config = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CART_PAGE)
        Double grandTotal = cart?.total
        Map model = [
            params: params, grandTotal: grandTotal,
            name: DomainConstants.AUTO_GENERATED_PAGES.CART_PAGE, cart: cart,
            config: config, continueShoppingUrl: continueShoppingUrl,
            eCommerceConfig: eCommerceConfig, view: "site/cartDetails.gsp"
        ]
        model = HookManager.hook("cart-details-page-model", model)
        String view = "/site/siteAutoPage";
        view = HookManager.hook("auto-page-view-model", view, model);
        render(view: view, model: model)
    }

    def updateQuantity() {
        String quantity = params.quantity
        String cartItemId = params.cartItemId;
        Cart cart = CartManager.getCart(session.id, false)
        if (cart == null) {
            render([status : "error", message: g.message(code:"your.shopping.cart.empty")] as JSON);
            return;
        }
        Map errorResponseMap = CartManager.updateCart(cart, [(cartItemId): quantity])
        CartItem cartItem = CartManager.getCartItem(cartItemId.toInteger(), cart)
        String status = "success"
        String message = null
        if (errorResponseMap["error-" + cartItemId]) {
            status = "error"
            message = errorResponseMap["error-" + cartItemId]
        } else if (errorResponseMap["warning-" + cartItemId]){
            status = "alert"
            message = errorResponseMap["warning-" + cartItemId]
        }
        Map model = [cart: cart, params: params, grandTotal: cart.total]
        model = HookManager.hook("cart-details-page-model", model)
        Map cartData = [
                cartDiscount: cart.discount.toCurrency().toPrice(),
                cartTax: cart.tax.toCurrency().toPrice(),
                cartDisplaySubTotal: cart.cartPageDisplaySubTotal.toCurrency().toPrice(),
                cartGrandTotal: model.grandTotal.toCurrency().toPrice()
        ]
        Map cartItemsData = [:]
        for(CartItem item : cart.cartItemList) {
            cartItemsData[item.id] = [
                cartItemQuantity: item.quantity,
                cartItemTax: item.tax.toCurrency().toPrice(),
                cartItemDiscount: item.discount.toCurrency().toPrice(),
                cartItemDisplayUnitPrice: item.displayUnitPrice.toCurrency().toPrice(),
                cartItemDisplayTotal: item.cartPageDisplayTotal.toCurrency().toPrice(),
                cartItemDiscountedUnitPrice: item.displayDiscountedUnitPrice.toCurrency().toPrice()
            ]
        }
        render([
            status: status,
            message: message,
            cartData: cartData,
            cartItemsData: cartItemsData
        ] as JSON)
    }

    def revertDirtyQuantity() {
        def cart = CartManager.getCart(session.id);
        cart?.cartItemList.each {
            it.oldQuantity = 0
        }
        render([status: "success"] as JSON)
    }
}
