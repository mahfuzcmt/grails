package com.webcommander.payment

import com.webcommander.ApplicationTagLib
import com.webcommander.AutoGeneratedPage
import com.webcommander.admin.Customer
import com.webcommander.admin.StoreCreditHistory
import com.webcommander.annotations.Initializable
import com.webcommander.common.CommanderMailService
import com.webcommander.constants.DomainConstants
import com.webcommander.constants.NamedConstants
import com.webcommander.events.AppEventManager
import com.webcommander.log.WcLogManager
import com.webcommander.manager.CacheManager
import com.webcommander.manager.CartManager
import com.webcommander.models.AddressData
import com.webcommander.models.CardInfo
import com.webcommander.models.Cart
import com.webcommander.models.PaymentInfo
import com.webcommander.oauth2.OAuthClient
import com.webcommander.throwables.PaymentGatewayException
import com.webcommander.util.AppUtil
import com.webcommander.webcommerce.*
import grails.gorm.transactions.Transactional
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.beans.factory.annotation.Qualifier
import org.springframework.web.context.request.RequestContextHolder
import com.webcommander.tenant.Thread
import javax.servlet.http.HttpSession

@Initializable
class PaymentService {

    @Autowired
    @Qualifier("com.webcommander.ApplicationTagLib")
    ApplicationTagLib app
    CommanderMailService commanderMailService
    ProductService productService
    OrderService orderService

    static void initialize() {
        AppEventManager.on("before-operator-delete", { id ->
            StoreCreditHistory.executeUpdate("update StoreCreditHistory p set p.createdBy = null where p.createdBy.id = :uid", [uid: id])
        })

        AppEventManager.on("before-customer-delete", { id ->
            Customer customer = Customer.proxy(id)
            StoreCreditHistory.createCriteria().list {
                eq("customer.id", id)
            }.each {
                AppEventManager.fire("before-StoreCreditHistory-delete", [it.id])
                customer.removeFromStoreCreditHistories(it)
                it.delete()
                AppEventManager.fire("StoreCreditHistory-delete", [it.id])
            }
            customer.save()
        })
    }

    private static List getPaymentEntryHolder() {
        List paymentEntryHolder = CacheManager.get(NamedConstants.CACHE.TENANT_STATIC, "payment_entry_holder")
        if(paymentEntryHolder == null) {
            CacheManager.cache(NamedConstants.CACHE.TENANT_STATIC, paymentEntryHolder = Collections.synchronizedList([]), -1, "payment_entry_holder")
        }
        return paymentEntryHolder
    }

    synchronized void storePaymentEntry(Long paymentId) {
        paymentEntryHolder.add([time: System.currentTimeMillis(), id: paymentId])
    }

    private synchronized void refreshPaymentCache() {
        Long current = System.currentTimeMillis()
        Long threshold = 60 * 60 * 1000
        paymentEntryHolder.removeAll {current - it.time > threshold}
    }

    Boolean hasPaymentEntry(Long paymentId) {
        return paymentEntryHolder.find {
            return it.id == paymentId
        } != null
    }

    @Transactional
    void processPostPayment(List<PaymentInfo> paymentInfoList) {
        if(paymentInfoList) {
            Cart cart = CartManager.getCart(AppUtil.session.id, false);
            Order order
            if(cart && cart.orderId) {
                order = Order.proxy(cart.orderId);
            }
            updateOrderPaymentStatus(order)
            Collection<Cart> carts = CartManager.removeCart {it.orderId == order.id}
            if(order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.PAID) {
                AppEventManager.fire("paid-for-cart", [carts])
            }
            Thread.start {
                Thread.sleep(10000) // let the transaction be flushed
                AppUtil.initialDummyRequest()
                orderService.sendEmailForOrder(order.id, order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.PAID ? "payment-success" : "payment-pending")
            }
        }
    }

    @Transactional
    public Payment processPostPayment(PaymentInfo payment, String status, Payment _payment = null) {
        if(!payment) {
            return null;
        }
        refreshPaymentCache()
        _payment = _payment ?: paymentEntryHolder.findResult {
            if(it.id == payment.paymentRef) {
                return Payment.get(payment.paymentRef)
            }
        }
        if(_payment) {
            paymentEntryHolder.removeAll {it.id == payment.paymentRef}
        } else {
            Cart cart = CartManager.getCart(AppUtil.session.id, false);
            if(cart && cart.orderId) {
                Order order = Order.proxy(cart.orderId);
                _payment = order.payments.find {it.id == payment.paymentRef}
            }
            if(!_payment) {
                return null;
            }
        }
        _payment.status = status;
        _payment.amount = payment.amount
        _payment.trackInfo = payment.trackInfo
        _payment.payerInfo = payment.payerInfo
        _payment.gatewayResponse = payment.gatewayResponse
        _payment.merge()
        if(_payment.status == DomainConstants.PAYMENT_STATUS.FAILED || _payment.status == DomainConstants.PAYMENT_STATUS.CANCELLED) {
            return _payment;
        }
        Order order = _payment.order
        if(_payment.status == DomainConstants.PAYMENT_STATUS.SUCCESS) {
            order.totalSurcharge += _payment.surcharge
        }
        updateOrderPaymentStatus(order)
        Collection<Cart> carts = CartManager.removeCart {it.orderId == order.id}
        if(order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.PAID) {
            AppEventManager.fire("paid-for-cart", [carts])
            AppEventManager.fire("after-payment-done", [order])
        } else if(_payment.status == DomainConstants.PAYMENT_STATUS.PENDING) {
            AppEventManager.fire('payment-pending-for-cart', [carts])
        }
        Thread.start {
            Thread.sleep(10000) // let the transaction be flushed
            AppUtil.initialDummyRequest()
            orderService.sendEmailForOrder(order.id, order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.PAID ? "payment-success" : "payment-pending")
        }
        return _payment
    }

    public void updateOrderPaymentStatus(Order order) {
        if(!order.due) {
            order.paymentStatus = DomainConstants.ORDER_PAYMENT_STATUS.PAID
            def updateStockConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.E_COMMERCE, "update_stock")
            if (updateStockConfig == DomainConstants.UPDATE_STOCK.AFTER_PAYMENT) {
                String note = "After payment for order #${order.id}"
                order.items.each {
                    if (it.productType == NamedConstants.CART_OBJECT_TYPES.PRODUCT){
                        productService.updateStock(it.productId, it.quantity, note, [orderItemId: it.id, variations: it.variations])
                    }
                }
            }
        } else if(order.paid) {
            order.paymentStatus = DomainConstants.ORDER_PAYMENT_STATUS.PARTIALLY_PAID
        } else {
            order.paymentStatus = DomainConstants.ORDER_PAYMENT_STATUS.UNPAID
        }
        order.merge()
    }
    
    private void renderOfflinePaymentPage(Cart cart, Closure renderer) {
        PaymentInfo info = new PaymentInfo();
        Payment payment = cart.tagged.payment;
        info.success = true;
        info.paymentRef = payment.id;
        info.amount = payment.amount;
        def session = AppUtil.session;
        info.payerInfo = session.customer ? "Customer# " +  session.customer : "Guest Customer";
        Map flashMap = [:];
        flashMap.pending = true;
        flashMap.payment = info;
        def flash = RequestContextHolder.currentRequestAttributes().getFlashScope()
        flash.param = flashMap;
        AppUtil.response.sendRedirect(app.baseUrl() + "payment/" + (info.success ? "success" : "failed"))
    }

    void renderPISPaymentPage(Cart cart, Closure renderer) {
        renderOfflinePaymentPage(cart, renderer)
    }

    void renderCHQPaymentPage(Cart cart, Closure renderer) {
        renderOfflinePaymentPage(cart, renderer)
    }

    void renderMORPaymentPage(Cart cart, Closure renderer) {
        renderOfflinePaymentPage(cart, renderer)
    }

    void renderBDPPaymentPage(Cart cart, Closure renderer) {
        renderOfflinePaymentPage(cart, renderer)
    }

    void renderACPPaymentPage(Cart cart, Closure renderer) {
        renderOfflinePaymentPage(cart, renderer)
    }

    void renderPPLPaymentPage(Cart cart, Closure renderer) {
        String serviceUrl;
        String email;
        String cancelScheme = "http";
        String successScheme = "http";
        String notifyScheme = "http";
        def configs = PaymentGatewayMeta.findAllByFieldFor(DomainConstants.PAYMENT_GATEWAY_CODE.PAYPAL)
        configs.each {
            if(it.name == "mode") {
                if (it.value == 'live') {
                    notifyScheme = 'https';
                    serviceUrl = DomainConstants.PPL_SERVICE_URL.LIVE;
                } else {
                    serviceUrl = DomainConstants.PPL_SERVICE_URL.TEST;
                }
            } else if(it.name == "emailAddress") {
                email = it.value
            }
        }
        HttpSession session = AppUtil.session
        AddressData address = session.effective_billing_address
        if(!address && AppUtil.session.customer) {
            Customer customer = Customer.get(AppUtil.session.customer)
            address = new AddressData(customer.address)
        }

        String itemNumbers = "Store Receipt";

        AutoGeneratedPage page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.CHECKOUT);
        if(page.isHttps) {
            notifyScheme = "https"
            cancelScheme = "https";
        }
        page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.PAYMENT_SUCCESS_PAGE);
        if(page.isHttps) {
            notifyScheme = "https"
            successScheme = "https";
        }
        Map requestMap = [
            ServiceUrl: serviceUrl,
            Email: email,
            Amount: (cart.tagged.payable + cart.tagged.surcharge).toPrice(),
            Currency: AppUtil.baseCurrency.code,
            CustomerFirstName: address.firstName,
            CustomerLastName: address.lastName,
            CustomerAddress1: address.addressLine1,
            CustomerAddress2: address.addressLine2,
            CustomerCity: address.city ?: "",
            CustomerState: address.stateName ?: "",
            CustomerPostCode: address.postCode ?: "",
            CustomerCountry: address.countryName ?: "",
            CustomerEmail: address.email,
            CustomerPhone: address.phone ?: "",
            CancelURL: app.baseUrl(scheme: cancelScheme) + "payPal/cancelPayment",
            ReturnUrl: app.baseUrl(scheme: successScheme) + "payPal/returnPayment",
            NotifyUrl: app.baseUrl(scheme: notifyScheme) + "payPal/notifyPayment",
            MerchantReference: "" + cart.tagged.payment.id,
            MerchantInvoice: "" + cart.orderId,
            itemNumber: itemNumbers
        ]

        String log = "\nAction: Redirecting to PayPal\nRequestData:\n${AppUtil.getQueryStringFromMap(requestMap)}\n"
        WcLogManager.log(log, "PayPalLogger")
        renderer(view: "/payment/paypal", model: [requestMap: requestMap, address: address])
    }

    void renderCRDPaymentPage(Cart cart, Closure renderer) {
        def creditCard = PaymentGatewayMeta.findByFieldFor(DomainConstants.PAYMENT_GATEWAY_CODE.CREDIT_CARD)
        "render${creditCard.value}CRDPaymentPage"(cart, renderer)
    }

    Boolean hasAwaitingPayment(Long orderId) {
        Order order = Order.get(orderId);
        return order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.PARTIALLY_PAID || order.paymentStatus == DomainConstants.ORDER_PAYMENT_STATUS.UNPAID;
    }

    public PaymentInfo processCRDAPIPayment(Payment payment, Map params) {
        def creditCard = PaymentGatewayMeta.findByFieldFor(DomainConstants.PAYMENT_GATEWAY_CODE.CREDIT_CARD)
        CardInfo cardInfo = new CardInfo(params.holderName, params.cardNumber, params.cvv, params.expiryMonth, params.expiryYear)
        PaymentInfo paymentInfo = this."process${creditCard.value}CRDAPIPayment"(cardInfo, payment)
        return paymentInfo
    }

    public void processCRDWalletPayment(Map params, Closure redirect) {
        def creditCard = PaymentGatewayMeta.findByFieldFor(DomainConstants.PAYMENT_GATEWAY_CODE.CREDIT_CARD)
        this."process${creditCard.value}WalletPayment"(params, redirect)
    }

    public PaymentInfo processSCRAPIPayment(Payment payment, Map params) {
        Customer customer = AppUtil.loggedCustomer ? Customer.get(AppUtil.loggedCustomer) : null
        if(customer == null) {
            throw new PaymentGatewayException("no.customer.logged.in")
        }
        if(customer.storeCredit < payment.amount) {
            throw new PaymentGatewayException("insufficient.store.credit")
        }
        customer.lock()
        customer.refresh()
        customer.storeCredit = customer.storeCredit - payment.amount
        customer.merge();
        StoreCreditHistory history = new StoreCreditHistory(customer: customer, deltaAmount: -1 * payment.amount, note: "After Order#${payment.orderId} payment")
        history.save()
        OAuthClient client = OAuthClient.get(AppUtil.APIClientId)
        PaymentInfo info = new PaymentInfo()
        info.amount = payment.amount
        info.trackInfo = "API Payment,\nApplication Name: ${client.displayName}"
        info.paymentRef = payment.id
        info.payerInfo = "Customer# " + customer.id;
        info.success = true
        return info
    }
}
