package com.webcommander.plugin.payway_payment_gateway

import com.webcommander.ApplicationTagLib
import com.webcommander.AutoGeneratedPage
import com.webcommander.admin.Customer
import com.webcommander.constants.DomainConstants
import com.webcommander.manager.CartManager
import com.webcommander.manager.HookManager
import com.webcommander.manager.PathManager
import com.webcommander.models.AddressData
import com.webcommander.models.CardInfo
import com.webcommander.models.Cart
import com.webcommander.models.PaymentInfo
import com.webcommander.plugin.payway_payment_gateway.constant.Messages
import com.webcommander.throwables.ApplicationRuntimeException
import com.webcommander.throwables.PaymentGatewayException
import com.webcommander.util.AppUtil
import com.webcommander.util.Base64Coder
import com.webcommander.util.HttpUtil
import com.webcommander.webcommerce.*
import com.qvalent.payway.PayWayAPI
import grails.converters.JSON
import grails.gorm.transactions.Transactional
import grails.util.Holders
import grails.util.TypeConvertingMap
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import java.security.MessageDigest
import com.webcommander.common.LargeData

@Transactional
class PayWayPaymentService {
    static ApplicationTagLib _app
    static getApp() {
        if(!_app) {
            return _app = Holders.grailsApplication.mainContext.getBean(ApplicationTagLib)
        }
        return _app
    }

    static {
        HookManager.register("before-PAYWAY-wallet-save", { CreditCard card, Map params ->
            def payWayPaymentService = AppUtil.getBean(PayWayPaymentService)
            String response = payWayPaymentService.sendTokenRequest(params)
            return payWayPaymentService.saveCreditCard(card, response)
        })
    }

    private String sendTokenRequest(Map cardInfo) {
        Map paymentInfo = [:]
        PaymentGatewayMeta.findAllByFieldFor(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY).each {
            if(it.name == "walletMode") {
                paymentInfo.walletMode = it.value
            } else if(it.name == "walletMerchantId") {
                paymentInfo.walletMerchantId = it.value
            } else if(it.name == "walletMerchantPublicApiKey") {
                paymentInfo.walletMerchantPublicApiKey = it.value
            } else if(it.name == "walletMerchantPrivateApiKey") {
                paymentInfo.walletMerchantPrivateApiKey = it.value
            }
        }
        String endPoint = "https://api.payway.com.au/rest/v1/single-use-tokens"

        String authString = Base64Coder.encode(paymentInfo.walletMerchantPublicApiKey + ":")
        Map requestMap = [
            paymentMethod  : "creditCard",
            cardNumber     : cardInfo.cardNumber,
            cardholderName : cardInfo.cardHolderName,
            cvn            : cardInfo.cvn,
            expiryDateMonth: cardInfo.expireMonth,
            expiryDateYear : cardInfo.expireYear
        ]

        String queryString = AppUtil.getQueryStringFromMap(requestMap)
        String response = HttpUtil.doPostRequest(endPoint, queryString, [
                Authorization : "Basic " + authString
        ])
        String token = JSON.parse(response)["singleUseTokenId"]
        String content = createPayWayCustomer(paymentInfo, token)

        return content
    }

    private String createPayWayCustomer(Map paymentInfo, String token) {
        Customer customer = Customer.load(AppUtil.loggedCustomer)
        String endPoint = "https://api.payway.com.au/rest/v1/customers"
        String authString = Base64Coder.encode(paymentInfo.walletMerchantPrivateApiKey + ":")
        Map requestMap = [
            singleUseTokenId: token,
            merchantId      : paymentInfo.walletMerchantId,
            customerName    : customer.fullName,
            emailAddress    : customer.address.email
        ]

        String queryString = AppUtil.getQueryStringFromMap(requestMap)
        String content = HttpUtil.doPostRequest(endPoint, queryString, [
                Authorization : "Basic " + authString
        ])
        return content
    }

    private CreditCard saveCreditCard(CreditCard card, String response) {
        Map resp = JSON.parse(response)
        Map creditCard = resp.paymentSetup.creditCard

        card.cardHolderName = creditCard.cardholderName
        card.cardMonth = creditCard.expiryDateMonth
        card.cardYear = creditCard.expiryDateYear
        card.gatewayName = DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY
        card.gatewayToken = resp.customerNumber

        return card
    }

    def paywayHostedToken(Map configMap, AddressData billingAddress, Cart cart) {
        Currency currency = AppUtil.baseCurrency
        if(currency.code != "AUD") {
            throw new ApplicationRuntimeException("could.not.contact.payment.provider.sorry.inconvenience")
        }
        Order order = Order.get(cart.orderId)
        AutoGeneratedPage page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.PAYMENT_SUCCESS_PAGE)
        String successScheme = "http"
        if(page.isHttps) {
            successScheme = "https"
        }
        Map models = [
            username: configMap["userName"],
            password: configMap["password"],
            biller_code: configMap["billerCode"],
            merchant_id: configMap.mode == "test" ? "TEST" : configMap["merchantId"],
            paypal_email: configMap["payPalEmail"] ?: "",
            information_fields: "First Name,Last Name,Email,Address 1,Address 2,Country,State,Suburb/City,Postcode",
            "First Name": billingAddress.firstName ?: "",
            "Last Name": billingAddress.lastName ?: "",
            Email: billingAddress.email,
            "Address 1": billingAddress.addressLine1 ?: "",
            "Address 2": billingAddress.addressLine2 ?: "",
            Country: billingAddress.countryName ?: "",
            State: billingAddress.stateName ?: "",
            "Suburb/City": billingAddress.city ?: "",
            Postcode: billingAddress.postCode,
            payment_reference: order.id,
            payment_reference_change: "false",
            payment_reference_text: "Order ID",
            payment_amount: (cart.tagged.payable + cart.tagged.surcharge).toCurrency().toPrice(),
            return_link_url: app.baseUrl(scheme: successScheme) + "payWay/paymentReturn?paymentId",
            return_link_redirect: "true",
            return_link_payment_status: "approved",
            hidden_fields: "paymentId",
            paymentId: "" + cart.tagged.payment.id
        ]
        if(configMap.stsNotification) {
            models.reply_link_url = app.baseUrl(scheme: "https")  + "payWay/paymentNotify"
            models.reply_link_post_type = "extended"
            models.reply_link_email = configMap.stsFailedEmail
            if(configMap.notificationEmail) {
                models.payment_alert = configMap.notificationEmail
            }
        }
        order.items.each {
            models.put(it.productName.encodeAsURL(), it.quantity + "," + it.totalPrice)
        }
        String requestUrl = "https://www.payway.com.au/RequestToken"
        URLConnection con = new URL(requestUrl).openConnection()
        con.setDoOutput(true)
        con.setDoInput(true)
        OutputStream outputStream = con.getOutputStream()
        outputStream << new ByteArrayInputStream(AppUtil.getQueryStringFromMap(models).getBytes("UTF-8"))
        outputStream.close()
        InputStream stream = con.getInputStream()
        ByteArrayOutputStream output = new ByteArrayOutputStream()
        output << stream
        String responseContent = output.toString()
        return [token: responseContent.split("=")[1], biller_code: configMap["billerCode"]]
    }

    PaymentInfo resolveInfoFromReturn(Map params) {
        PaymentInfo info = new PaymentInfo()
        String status = params.summary_code == "0" ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        info.amount = params.payment_amount.toDouble()
        info.paymentRef = params.paymentId.toLong()
        info.payerInfo = params.remote_ip
        info.gatewayResponse = params.response_text
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        info.trackInfo = params.bank_reference
        return info
    }

    PaymentInfo resolveInfoFromNotification(TypeConvertingMap params) {
        PaymentInfo info = new PaymentInfo()
        String status = params.cd_summary == "0" ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        info.amount = params.am_payment.toDouble()
        info.paymentRef = params.long("paymentId")
        info.payerInfo = params.nm_card_holder + " (" + params.TruncatedCardNumber + ")"
        info.gatewayResponse = params.tx_response
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        info.trackInfo = params.no_receipt
        return info
    }

    PaymentInfo processApiPayment(CardInfo cardInfo, Double amount, Long orderId, Long paymentId) {
        def configs = PaymentGatewayMeta.findAllByFieldFor(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY)
        Map configMap = [:]
        configs.each {
            configMap[it.name] = it.value
        }
        Map requstData = [:]
        requstData["customer.username"] = configMap["userName"]
        requstData["customer.password"] = configMap["password"]
        requstData["customer.merchant"] = configMap.mode == "test" ? "TEST" : configMap["merchantId"]
        requstData["order.type"] = "capture"
        requstData["order.amount"] = Math.round(amount * 100).toString()
        requstData["card.currency"] = "AUD"
        requstData["order.ECI"] = "SSL"
        requstData["customer.orderNumber"] = orderId + "-" + paymentId
        requstData["card.PAN"] = cardInfo.cardNumber
        requstData["card.CVN"] = cardInfo.cvv
        requstData["card.expiryMonth"] = cardInfo.expiryMonth
        requstData["card.expiryYear"] = cardInfo.expiryYear
        String truncatedCardNumber = cardInfo.cardNumber
        truncatedCardNumber = truncatedCardNumber.substring(0, 4) + "..." + truncatedCardNumber.substring(truncatedCardNumber.length() - 4, truncatedCardNumber.length())
        PayWayAPI paywayAPI = new PayWayAPI()

        String certificateFile = PathManager.getCustomRestrictedResourceRoot("certificates/payway.cert")
        if(!new File(certificateFile).exists()) {
            File certFile = new File(certificateFile)
            certFile.parentFile.mkdirs()
            certFile.createNewFile()
            LargeData dbCertificate = LargeData.findByName("payway-payment-gateway-payway.cert")
            if(dbCertificate) {
                certFile.text = new String(dbCertificate.content, "UTF-8")
            }
        }
        paywayAPI.initialise("certificateFile=" + certificateFile + "&logDirectory=${System.getProperty('catalina.home')}/logs")
        String requestQuery = paywayAPI.formatRequestParameters(requstData.findAll { it ->
            return it.key.indexOf(".") != -1
        })
        String responseData = paywayAPI.processCreditCard(requestQuery)
        Map responseParams = paywayAPI.parseResponseParameters(responseData)
        PaymentInfo info = new PaymentInfo()
        String summaryCode = responseParams["response.summaryCode"]
        String status = summaryCode == "0" ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        info.paymentRef = paymentId
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        info.amount = amount
        info.payerInfo = AppUtil.loggedCustomer ? "Customer#" +  AppUtil.loggedCustomer : "Guest Customer" + "(" + truncatedCardNumber + ")"
        info.gatewayResponse = responseParams['response.text'] ?: responseParams["response.responseCode"]
        info.trackInfo = responseParams["response.receiptNo"]
        if(status == DomainConstants.PAYMENT_STATUS.FAILED) {
            String errorMessage = Messages.API_ERROR_RESPONSE_MESSAGES[summaryCode][responseParams["response.responseCode"]] ?: "could.not.process.payment.contact.with.vendor"
            throw new PaymentGatewayException(errorMessage, [], info)
        }
        return info
    }

    PaymentInfo processWalletPayment(Map params) {
        def session = AppUtil.session
        Cart cart = CartManager.getCart(session.id, true)
        Double amount = cart.tagged.payable + cart.tagged.surcharge
        Order order = Order.load(cart.orderId)
        Payment payment = Payment.load(cart.tagged.payment.id)
        CreditCard card = CreditCard.load(params.walletPayment)

        def configs = PaymentGatewayMeta.findAllByFieldFor(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY)
        Map configMap = [:]
        configs.each {
            configMap[it.name] = it.value
        }

        String endPoint = "https://api.payway.com.au/rest/v1/transactions"
        String authString = Base64Coder.encode(configMap.walletMerchantPrivateApiKey + ":")
        Map requestMap = [
            customerNumber : card.token,
            merchantId     : configMap.walletMerchantId,
            transactionType: "payment",
            principalAmount: amount.round(2),
            currency       : "aud",
            orderNumber    : order.id
        ]

        String queryString = AppUtil.getQueryStringFromMap(requestMap)
        String response = HttpUtil.doPostRequest(endPoint, queryString, [
                Authorization : "Basic " + authString
        ])
        Map respMap = JSON.parse(response)

        PaymentInfo info = new PaymentInfo()
        String status = respMap.status == "approved" ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        info.paymentRef = payment.id
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        info.amount = amount
        info.payerInfo = AppUtil.loggedCustomer ? "Customer#" +  AppUtil.loggedCustomer : "Guest Customer" + "(" + respMap.creditCard.cardNumber + ")"
        info.gatewayResponse = respMap.responseCode
        info.trackInfo = respMap.transactionId
        if(status == DomainConstants.PAYMENT_STATUS.FAILED) {
            String errorMessage = Messages.API_ERROR_RESPONSE_MESSAGES[respMap.summaryCode][respMap["responseCode"]] ?: "could.not.process.payment.contact.with.vendor"
            throw new PaymentGatewayException(errorMessage, [], info)
        }
        card.plusPaymentCount()
        card.plusPaymentTotal(amount)
        card.save()
        return info
    }

    PaymentInfo processApiPayment(Map params) {
        def session = AppUtil.session
        Cart cart = CartManager.getCart(session.id, true)
        CardInfo cardInfo = new CardInfo("", params["card.PAN"], params["card.CVN"], params["card.expiryMonth"], params["card.expiryYear"])
        Double amount = cart.tagged.payable + cart.tagged.surcharge
        return processApiPayment(cardInfo, amount, cart.orderId, cart.tagged.payment.id)
    }

    Map decryptNetReturnData(String encryptedParametersText, String signatureText) {
        PaymentGatewayMeta encryptionKeyEntry = PaymentGatewayMeta.findByFieldForAndName(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY, "encryptionKey")
        final byte[] keyBytes = new Base64Coder().decode(encryptionKeyEntry.value)
        final byte[] encryptedParametersBytes = new Base64Coder().decode(encryptedParametersText)
        final SecretKey key = new SecretKeySpec(keyBytes, "AES")
        final IvParameterSpec iv = new IvParameterSpec(new byte[16])
        final Cipher cipher = Cipher.getInstance( "AES/CBC/PKCS5Padding" )
        cipher.init(Cipher.DECRYPT_MODE, key, iv)
        final byte[] parametersBytes = cipher.doFinal( encryptedParametersBytes )
        final String parametersText = new String( parametersBytes )
        final MessageDigest md5 = MessageDigest.getInstance("MD5")
        final byte[] computedHash = md5.digest( parametersBytes )
        final byte[] signatureBytes = new Base64Coder().decode( signatureText )
        final byte[] hash = cipher.doFinal( signatureBytes )
        if (hash != computedHash) {
            throw new ApplicationRuntimeException("invalid.request")
        }
        return WebUtils.fromQueryString(parametersText)
    }

    void verifyNotification(String username, String password) {
        if(PaymentGatewayMeta.findByFieldForAndName(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY, "userName").value != username) {
            throw new ApplicationRuntimeException("invalid.notification")
        }
        if(PaymentGatewayMeta.findByFieldForAndName(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.PAYWAY, "password").value != password) {
            throw new ApplicationRuntimeException("invalid.notification")
        }
    }
}
