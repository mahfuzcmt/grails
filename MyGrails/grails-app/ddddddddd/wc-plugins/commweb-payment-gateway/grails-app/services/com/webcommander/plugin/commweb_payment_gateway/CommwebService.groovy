package com.webcommander.plugin.commweb_payment_gateway

import com.webcommander.ApplicationTagLib
import com.webcommander.AutoGeneratedPage
import com.webcommander.constants.DomainConstants
import com.webcommander.manager.CartManager
import com.webcommander.models.AddressData
import com.webcommander.models.CardInfo
import com.webcommander.models.Cart
import com.webcommander.models.PaymentInfo
import com.webcommander.throwables.ApplicationRuntimeException
import com.webcommander.throwables.PaymentGatewayException
import com.webcommander.util.AppUtil
import com.webcommander.util.HttpUtil
import com.webcommander.webcommerce.PaymentGatewayMeta
import grails.gorm.transactions.Transactional
import grails.util.Holders

@Transactional
class CommwebService {
    static ApplicationTagLib _app
    static getApp() {
        if(!_app) {
            return _app = Holders.grailsApplication.mainContext.getBean(ApplicationTagLib)
        }
        return _app
    }

    PaymentInfo resolveInfo(Map params) {
        PaymentInfo info = new PaymentInfo()
        def session = AppUtil.session
        String status = (params.vpc_txnresponseCode == "00") ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        info.amount = params.vpc_Amount.toDouble()  / 100;
        info.paymentRef = params["vpc_MerchTxnRef"].toLong();
        info.payerInfo =  session.customer ? "Customer#" +  session.customer : "Guest Customer"
        info.gatewayResponse = params.vpc_Message
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        info.trackInfo = params.vpc_transactionNo
        return info
    }

    public def processNetPayment(Map configMap, AddressData billingAddress, Cart cart) {
        def currency = AppUtil.session.currency ?: AppUtil.baseCurrency
        if(currency.code != "AUD") {
            throw new ApplicationRuntimeException("currency.not.supported", [currency.name])
        }
        AutoGeneratedPage page = AutoGeneratedPage.findByName(DomainConstants.AUTO_GENERATED_PAGES.PAYMENT_SUCCESS_PAGE)
        String successScheme = page.isHttps ? "https" : "http"
        String total = Math.round((cart.tagged.payable + cart.tagged.surcharge).toCurrency() * 100)
        String reference = "" + cart.tagged.payment.id
        String cancelUrl = app.baseUrl(scheme: successScheme) + "commweb/paymentCancel";
        String returnUrl = app.baseUrl(scheme: successScheme) + "commweb/paymentReturn"
        Map models = [
            AgainLink: cancelUrl,
            vpc_AccessCode: configMap.access_code,
            vpc_Amount: total,
            vpc_Command: "pay",
            vpc_Locale: "en",
            vpc_MerchTxnRef: reference,
            vpc_Merchant: configMap.merchantId,
            vpc_OrderInfo: "Order# " + cart.orderId,
            vpc_ReturnURL: returnUrl,
            vpc_TicketNo: reference,
            vpc_Version: "1",
            vpc_SecureHash: configMap.secret_code.encodeAsMD5()
        ]
        return [models: models, requestUrl: "https://migs.mastercard.com.au/vpcpay"]
    }

    PaymentInfo processApiPayment(CardInfo cardInfo, Double amount, Long orderId, Long paymentId) {
        def currency = AppUtil.session.currency ?: AppUtil.baseCurrency
        if(currency.code != "AUD") {
            throw new ApplicationRuntimeException("currency.not.supported", [currency.name])
        }
        def configs = PaymentGatewayMeta.findAllByFieldFor(DomainConstants.CARD_PAYMENT_PROCESSOR_CODE.COMMWEB)
        Map configMap = [:]
        configs.each {
            configMap[it.name] = it.value
        }
        String reference = paymentId
        def total = amount.toCurrency()
        Map model = [
                vpc_CardNum: cardInfo.cardNumber,
                vpc_CardSecurityCode: cardInfo.cvv,
                vpc_AccessCode: configMap.access_code,
                vpc_Amount: Math.round(total * 100),
                vpc_Command: "pay",
                vpc_Locale: "en",
                vpc_MerchTxnRef: reference,
                vpc_Merchant: configMap.merchantId,
                vpc_OrderInfo: orderId,
                vpc_Version: "1",
                vpc_CardExp: cardInfo.expiryYear + cardInfo.expiryMonth
        ]
        String truncatedCardNumber =  cardInfo.cardNumber.substring(0, 4) + "..." + cardInfo.cardNumber.substring(cardInfo.cardNumber.length() - 4, cardInfo.cardNumber.length())
        Map logConf = [
            loggerName: "CommonWebLogger",
            replaces: [(cardInfo.cardNumber):  truncatedCardNumber]
        ]
        String url = "https://migs.mastercard.com.au/vpcdps"
        String response = HttpUtil.doPostRequest(url, AppUtil.getQueryStringFromMap(model), [:], true, logConf)
        Map properties = AppUtil.getURLQueryMap(response)
        String apiResponseCode = properties.vpc_TxnResponseCode
        String status = (apiResponseCode == "0") ? DomainConstants.PAYMENT_STATUS.SUCCESS : DomainConstants.PAYMENT_STATUS.FAILED
        if(apiResponseCode != "0") {
            String errorMessage = "could.not.process.payment.contact.with.vendor";
            if (apiResponseCode == "1") {
                errorMessage = "Transaction could not be processed"
            } else if(apiResponseCode == "E" || apiResponseCode == "2") {
                errorMessage = "Transaction declined - contact issuing bank"
            } else if(apiResponseCode == "3") {
                errorMessage = "No reply from Processing Host"
            } else if(apiResponseCode == "4") {
                errorMessage = "Card has expired"
            } else if(apiResponseCode == "5") {
                errorMessage = "Insufficient credit"
            }
            throw new PaymentGatewayException(errorMessage)
        }
        PaymentInfo info = new PaymentInfo()
        info.amount = properties["vpc_Amount"].toDouble() / 100;
        info.trackInfo = properties.vpc_TransactionNo
        info.gatewayResponse = properties.vpc_Message
        info.success = status == DomainConstants.PAYMENT_STATUS.SUCCESS
        if(AppUtil.loggedCustomer) {
            info.payerInfo = "Customer#" +  AppUtil.loggedCustomer
        } else {
            info.payerInfo = "Guest Customer (" + truncatedCardNumber + ")";
        }
        info.paymentRef = properties.vpc_MerchTxnRef.toLong()
        return info

    }

    PaymentInfo processApiPayment(Map params) {
        def session = AppUtil.session
        Cart cart = CartManager.getCart(session.id, true)
        CardInfo cardInfo = new CardInfo(params.vpc_CardNum, params.vpc_CardSecurityCode, params.cardExpiryMonth,params.cardExpiryYear)
        return processApiPayment(cardInfo, cart.tagged.payable + cart.tagged.surcharge, cart.orderId, cart.tagged["payment"].id)
    }
}
