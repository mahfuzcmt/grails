package com.webcommander.authentication

import com.webcommander.authentication.annotations.AutoGeneratedPage
import com.webcommander.authentication.annotations.License
import com.webcommander.authentication.annotations.RequiresAdmin
import com.webcommander.authentication.annotations.RequiresCustomer
import com.webcommander.authentication.annotations.Restriction
import com.webcommander.authentication.annotations.Restrictions
import com.webcommander.manager.LicenseManager
import com.webcommander.models.RestrictionPolicy
import grails.util.Holders
import grails.web.Action
import grails.core.GrailsClass
import grails.web.servlet.mvc.GrailsParameterMap
import org.codehaus.groovy.runtime.metaclass.MixinInstanceMetaMethod

import java.lang.annotation.Annotation
import java.lang.reflect.Method
import java.lang.reflect.Modifier

class ControllerAnnotationParser {

    private static List<String> adminRequiredControllers = new ArrayList<String>()
    private static List<String> customerRequiredControllers = new ArrayList<String>()
    private static List<String> adminRequiredActions = new ArrayList<String>()
    private static List<String> customerRequiredActions = new ArrayList<String>()
    private static List<String> adminRequiredExceptions = new ArrayList<String>()
    private static List<String> customerRequiredExceptions = new ArrayList<String>()

    private static Map<String, License> licenseRequireds = new HashMap<String, License>()
    private static Map<String, ArrayList> restrictionPolicies = new HashMap<>()

    private static Map<String, String> autoPageHashes = new HashMap<>()

    private static List<Method> getActionMethods(Class controller) {
        (controller.methods + Holders.grailsApplication.mainContext.getBean(controller).metaClass.methods.findAll {it instanceof MixinInstanceMetaMethod}.collect {it.method.cachedMethod}).findAll {Modifier.isPublic(it.modifiers) && it.getAnnotation(Action.class) != null}
    }

    /**
     * checks all controllers and actions authentication check requirement
     */
    static void init(GrailsClass[] controllers) {
        List<String> adminPatterns = Holders.config.webcommander.adminpackages.collect {
            it.replaceAll("\\.", "\\\\.").replaceAll("\\*", "[^\\\\.]+") + "\\..*"
        }
        for(GrailsClass controller : controllers) {
            Class clazz = controller.getClazz()
            boolean isAdmin = clazz.isAnnotationPresent(RequiresAdmin)
            if(!isAdmin) {
                for(String pattern : adminPatterns) {
                    isAdmin = clazz.getCanonicalName().matches(pattern)
                    if(isAdmin) {
                        break
                    }
                }
            }
            if(isAdmin) {
                adminRequiredControllers.add(controller.getName().toUpperCase())
                RequiresAdmin annot = (RequiresAdmin)clazz.getAnnotation(RequiresAdmin)
                if(annot != null) {
                    for(String exception : annot.exceptions()) {
                        adminRequiredExceptions.add((controller.getName() + "#" + exception).toUpperCase())
                    }
                }
            }
            boolean isCustomer = clazz.isAnnotationPresent(RequiresCustomer)
            if(isCustomer) {
                customerRequiredControllers.add(controller.getName().toUpperCase())
                RequiresCustomer annot = (RequiresCustomer)clazz.getAnnotation(RequiresCustomer)
                for(String exception : annot.exceptions()) {
                    customerRequiredExceptions.add((controller.getName() + "#" + exception).toUpperCase())
                }
            }
            for (Method method : getActionMethods(clazz)) {
                String endPoint = (controller.getName() + "#" + method.getName()).toUpperCase()
                isAdmin = method.isAnnotationPresent(RequiresAdmin)
                isCustomer = method.isAnnotationPresent(RequiresCustomer)
                if(isAdmin) {
                    adminRequiredActions.add(endPoint)
                }
                if(isCustomer) {
                    customerRequiredActions.add(endPoint)
                }
                Restrictions restrictions = method.getAnnotation(Restrictions)
                Closure getPolicy = { restriction ->
                    String fullPermission = restriction.permission()
                    def splitted = fullPermission.split("\\.")
                    RestrictionPolicy policy = new RestrictionPolicy(type: splitted[0], permission: splitted[1..splitted.size()-1].join("."))
                    if(restriction.condition() != void.class) {
                        policy.condition = restriction.condition().newInstance()
                    } else if(restriction.params_not_exist()) {
                        policy.condition = { params ->
                            !params[restriction.params_not_exist()]
                        }
                    } else if(restriction.params_exist()) {
                        policy.condition = { params ->
                            params[restriction.params_exist()]
                        }
                    } else if(restriction.params_match_key()) {
                        String[] keys = restriction.params_match_key()
                        List values = restriction.params_match_value() as List
                        policy.condition = { params ->
                            keys.collect {params[it]} == values
                        }
                    }
                    policy.entityParam = restriction.entity_param()
                    policy.domain = restriction.domain()
                    policy.ownerField = restriction.owner_field()
                    return policy
                }
                if(restrictions) {
                    List policies = []
                    restrictionPolicies[endPoint] = policies
                    restrictions.value().each { restriction ->
                        policies.add(getPolicy(restriction))
                    }
                } else {
                    Restriction restriction = method.getAnnotation(Restriction)
                    if(restriction) {
                        List policies = []
                        restrictionPolicies[endPoint] = policies
                        policies.add(getPolicy(restriction))
                    }
                }
                if(method.isAnnotationPresent(AutoGeneratedPage)) {
                    Annotation annot = method.getAnnotation(AutoGeneratedPage)
                    autoPageHashes.put((controller.getName() + "#" + method.getName()).toLowerCase(), annot.value())
                }
                if(method.isAnnotationPresent(License)) {
                    Annotation annot = method.getAnnotation(License)
                    licenseRequireds.putAt((controller.getName() + "#" + method.getName()).toLowerCase(), annot)
                }
            }
        }
    }

    /**
     * returns true if operator authentication is required
     */
    static boolean isAdminRequired(String controller, String action) {
        action = (controller + "#" + action).toUpperCase()
        return (adminRequiredControllers.contains(controller.toUpperCase()) && !adminRequiredExceptions.contains(action)) || adminRequiredActions.contains(action)
    }

    static List<RestrictionPolicy> getRestrictionPolicies(String controller, String action, Map params) {
        String endPoint = (controller + "#" + action).toUpperCase()
        def policies = restrictionPolicies[endPoint]
        if(policies) {
            return policies.findAll { policy ->
                if(policy.condition) {
                    return policy.condition(params)
                }
                return true
            }
        }
        return []
    }

    /**
     * returns true if customer authentication is required
     */
    static boolean isCustomerRequired(String controller, String action) {
        action = (controller + "#" + action).toUpperCase()
        return (customerRequiredControllers.contains(controller.toUpperCase()) && !customerRequiredExceptions.contains(action)) || customerRequiredActions.contains(action)
    }

    static String isAutoPage(String controller, String action) {
        String hash = (controller + "#" + action).toLowerCase()
        return autoPageHashes[hash]
    }

    static class ProvisionDisabledException extends RuntimeException {
        String license
        String featureName

        ProvisionDisabledException(String message, String license) {
            super(message)
            this.license = license
            this.featureName = license
            if(featureName.startsWith("allow_")) {
                featureName = featureName.substring(6)
            }
            if (featureName.endsWith("_feature")) {
                featureName = featureName.substring(0, featureName.length() - 8)
            }
            this.featureName = this.featureName.replaceAll("_", ".")
        }
    }

    static class ProvisionLimitCrossedException extends RuntimeException {
        String license
        String featureName
        Integer limit

        ProvisionLimitCrossedException(String message, String license, Integer limit) {
            super(message)
            this.license = license
            this.limit = limit
            this.featureName = license.substring(0, license.length() - 6).capitalize()
        }
    }

    static void checkProvision(String controller, String action, GrailsParameterMap params) {
        if(!LicenseManager.isProvisionActive()) {
            return
        }
        String hash = (controller + "#" + action).toLowerCase()
        License license = licenseRequireds[hash]
        if(license) {
            Class checker = license.checker()
            if(checker != void.class) {
                if(!license.checker().isApplicable(license.required(), params)) {
                    return
                }
            } else {
                checker = null
            }
            com.webcommander.models.License appliedLicense = LicenseManager.license(license.required())
            if(!appliedLicense) {
                throw new ProvisionDisabledException("feature.disabled", license.required())
            }
            if(checker && appliedLicense.limit) {
                Integer limitStatus = checker.limitCheck(appliedLicense, params)
                if(limitStatus == 1) {
                    throw new ProvisionLimitCrossedException("operation.denied.will.exceed.limit.feature", license.required(), appliedLicense.limit)
                } else if(limitStatus == 2) {
                }
            }
        }
    }
}
