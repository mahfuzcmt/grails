package com.webcommander.controllers.site

import com.webcommander.Page
import com.webcommander.admin.*
import com.webcommander.authentication.annotations.AutoGeneratedPage
import com.webcommander.authentication.annotations.RequiresCustomer
import com.webcommander.captcha.CaptchaService
import com.webcommander.common.CommanderMailService
import com.webcommander.config.StoreDetail
import com.webcommander.constants.DomainConstants
import com.webcommander.constants.NamedConstants
import com.webcommander.content.PageService
import com.webcommander.events.AppEventManager
import com.webcommander.manager.CacheManager
import com.webcommander.manager.CartManager
import com.webcommander.manager.HookManager
import com.webcommander.models.AddressData
import com.webcommander.models.Cart
import com.webcommander.tenant.Thread
import com.webcommander.throwables.ApplicationRuntimeException
import com.webcommander.util.AppUtil
import com.webcommander.util.security.InformationEncrypter
import com.webcommander.webcommerce.*
import com.webcommander.widget.Widget
import grails.converters.JSON

import javax.servlet.http.Cookie

class CustomerController {
    CustomerService customerService;
    CommanderMailService commanderMailService
    AdministrationService administrationService
    CaptchaService captchaService
    ConfigService configService
    ProductService productService
    PageService pageService
    OrderService orderService
    PaymentGatewayService paymentGatewayService

    @AutoGeneratedPage("login")
    def login() {
        if(session.customer && !(params.different_customer != null)) {
            String redirectUrl = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "after_login_url") ?: "/customer/profile"
            redirect(uri: redirectUrl)
        }
        Long failCount = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "fail_count").toLong()
        boolean useCaptcha = (session.login_attempt_failed_count > failCount) ? true : false;
        Map loginConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS)
        def regStatus =AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_REGISTRATION_SETTINGS, "registration_status_type")
        String view = "/site/siteAutoPage";
        Map model =  [name : DomainConstants.AUTO_GENERATED_PAGES.CUSTOMER_LOGIN, view: "site/customerLogin.gsp", referer: params.referer, useCaptcha: useCaptcha,
                      loginConfig: loginConfig, regStatus: regStatus];
        view = HookManager.hook("auto-page-view-model", view, model)
        render (view: view, model: model)
    }

    @RequiresCustomer()
    def logout() {
        CacheManager.removeCache("session", session.id, "customer", "" + (session.customer ?: 0))
        AppEventManager.fire("customer-logout", [session.customer])
        session.customer = null;
        session.effective_billing_address = null;
        session.effective_shipping_address = null;
        Cookie remember = request.getCookies().find {it.name.startsWith("remember-customer")};
        if (remember) {
            remember.maxAge = 0;
            remember.path = "/";
            response.addCookie(remember);
        }
        AppEventManager.fire("effective-billing-change", [session.id])
        AppEventManager.fire("effective-shipping-change", [session.id])
        redirect(uri: "/")
    }

    def loginFromWidget() {
        Boolean captchaValid = true;
        Long configuredFailCount = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "fail_count").toLong()
        String captchaStatusInSite = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, "captcha_setting")
        def widgetId = params.long("widget-id");
        Widget widget = Widget.get(widgetId);
        def config = JSON.parse(widget.params)

        if(session.login_attempt_failed_count > configuredFailCount && captchaStatusInSite  == "enable") {
            if(!captchaService.validateCaptcha(params, request)) {
                captchaValid = false;
            }
        }
        Map verificationInfo = customerService.verifyCustomer(params.name, params.password)
        if(captchaValid && verificationInfo.status == "verified") {
            Customer customer = verificationInfo.customer;
            session.login_attempt_failed_count = 0;
            CacheManager.removeCache("session", session.id, "customer", "" + (session.customer ?: 0))
            session.customer = customer.id
            AppEventManager.fire("customer-login", [session.customer])
            if(config.after_login == "same_page") {
                redirect(uri: "/" + params.pageUrl)
            } else {
                redirect(uri: "/customer/profile")
            }
        } else {
            session.login_attempt_failed_count = (session.login_attempt_failed_count ?: 0) + 1;
            if (config.after_failure == "same_page") {
                String error;
                if(!captchaValid) {
                    error = g.message(code: 'login.failed.invalid.captcha')
                } else {
                    error = g.message(code: verificationInfo.message)
                }
                flash.model = [error: error];
                redirect(uri: "/" + params.pageUrl)
            } else {
                redirect(uri: "/customer/login")
            }
        }
    }

    def doLogin () {
        boolean captchaValid = true;
        Map verificationInfo = customerService.verifyCustomer(params.userName, params.password)
        Long failCount = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "fail_count").toLong()
        def captchaStatus
        String error
        if(session.login_attempt_failed_count && session.login_attempt_failed_count > failCount ) {
            captchaStatus = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, "captcha_setting")
            if(captchaStatus == "enable"){
                if(!captchaService.validateCaptcha(params, request)) {
                    captchaValid = false;
                }
            }
        }
        if(captchaValid && verificationInfo.status == "verified") {
            Customer customer = verificationInfo.customer;
            CacheManager.removeCache("session", session.id, "customer", "" + (session.customer ?: 0))
            session.customer = customer.id
            AppEventManager.fire("customer-login", [session.customer])
            session.login_attempt_failed_count = 0
            if (params.remember) {
                InformationEncrypter rsa = new InformationEncrypter();
                rsa.hideInfo(params.userName)
                rsa.hideInfo(params.password)
                String key = (System.currentTimeMillis() + "").encodeAsMD5().encodeAsBase64() + "^" + rsa.toString();
                Cookie cookie = new Cookie("remember-customer", key);
                cookie.maxAge = 604800;
                cookie.path = "/";
                response.addCookie(cookie);
            } else {
                Cookie cookie = request.getCookies().find {it.name.startsWith("remember-customer")};
                if(cookie) {
                    cookie.maxAge = 0;
                    response.addCookie(cookie);
                }
            }
            String redirectUrl = params.referer ?: (AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "after_login_url") ?: "/customer/profile")
            redirect(uri: redirectUrl)
        } else {
            session.login_attempt_failed_count = (session.login_attempt_failed_count ?: 0) + 1;
            if(!captchaValid) {
                error = g.message(code: 'login.failed.invalid.captcha')
            } else {
                error = g.message(code: verificationInfo.message)
            }
            flash.model = [error: error];
            flash.param = [referer: params.referer]
            redirect(controller: "customer", action: "login");
        }
    }

    def doSocialLogin() {
        Map verificationInfo = customerService.verifyCustomerByToken(params.media, params.token)
        if(verificationInfo.status == "verified") {
            Customer customer = verificationInfo.customer;
            CacheManager.removeCache("session", session.id, "customer", "" + (session.customer ?: 0))
            session.customer = customer.id
            AppEventManager.fire("customer-login", [session.customer])
            String redirectUrl = params.referer ?: (AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_LOGIN_SETTINGS, "after_login_url") ?: "/customer/profile")
            render([status: "success", redirectUrl: redirectUrl] as JSON)
        } else {
            render([status: "error", message: verificationInfo.message] as JSON)
        }
    }

    @AutoGeneratedPage("reset.password")
    def resetPassword() {
        String view = "/site/siteAutoPage";
        Map model = [name : DomainConstants.AUTO_GENERATED_PAGES.CUSTOMER_RESET_PASSWORD]
        if(params.token) {
            model << [view: "site/customerNewPassword.gsp", token: params.token]
        } else {
            model << [view: "site/customerResetPassword.gsp"]
        }
        view = HookManager.hook("auto-page-view-model", view, model);
        render(view: view, model: model)
    }

    def passwordResetLink() {
        String message = null;
        String error = null;
        if(params.userName) {
            customerService.clearCustomerSession(session);
            String email = params.userName;
            Customer customer = Customer.findByUserName(email)
            if (!customer) {
                error = g.message(code: 'entered.email.address.not.exits')
            } else {
                InformationEncrypter rsa = new InformationEncrypter();
                rsa.hideInfo("" + customer.id);
                rsa.hideInfo("" + customer.userName);
                def resetPasswordLink = app.baseUrl() + "customer/resetPassword?token=" + rsa.toString().encodeAsURL();
                try {
                    customerService.sendResetPasswordMail(customer, resetPasswordLink)
                    message = g.message(code: 'email.with.password.reset.link.sent')
                } catch (Exception e) {
                    error = g.message(code: 'could.not.send.mail.try.later')
                }
            }
            flash.model = [message: message, error: error];
        }
        if(error) {
           redirect(uri: "/customer/resetPassword");
        } else {
           redirect(uri: "/customer/login");
        }
    }

    def changePassword() {
        String message = "";
        String error = "";
        String token = params.token;
        InformationEncrypter auth;
        try {
            auth = new InformationEncrypter(token, 60000 * 60 * 48);
        } catch(Throwable t) {
            error = g.message(code: 'unable.update.password.requested.link.expired')
            flash.param = [token: params.token]
            flash.model = [error: error];
            redirect(uri: "/customer/resetPassword");
            return;
        }
        def infos = auth.hiddenInfos;
        def customerId = infos.get(0).toInteger();
        if(customerService.updatePassword(customerId, params.password)) {
            message = g.message(code: 'password.change.success')
        } else {
            error = g.message(code: 'could.not.change.password.try.later')
        }
        flash.model = [message: message, error: error];
        redirect(uri: "/customer/login");
    }

    @AutoGeneratedPage("registration")
    def register() {
        Long defaultCountryId   = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, "default_country").toLong();
        Long defaultStateId     = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, "default_state").toLong();
        Map customerData = [:];
        params.collect {key, value ->
            customerData[key] = value;
        };
        customerData.remove("controller")
        customerData.remove("action")
        def states = administrationService.getStatesForCountry(defaultCountryId)
        boolean cityExists = administrationService.isCityExistsForCountry(defaultCountryId)
        Map configs = (Map)AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_REGISTRATION_SETTINGS)
        def registrationFieldConfigs = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_REGISTRATION_FIELD)
        List sortedFields = configService.getSortedFields(registrationFieldConfigs)
        Map fieldsConfigs = configService.getCustomerRegistrationFieldsConfigs(sortedFields, registrationFieldConfigs)
        List activeFields = configService.getActiveFields(sortedFields, fieldsConfigs)
        if(registrationFieldConfigs['registration_terms_active'].toBoolean()) {
            activeFields.push('registration_terms')
        }
        String view = "/site/siteAutoPage";
        Map model = [name: DomainConstants.AUTO_GENERATED_PAGES.CUSTOMER_REGISTRATION, view: "site/autopage/customerRegistration.gsp", defaultStateId: defaultStateId, customer: customerData, states: states, configs: configs, fieldsConfigs: fieldsConfigs, fields: activeFields, cityExists: cityExists]
        view = HookManager.hook("auto-page-view-model", view, model)
        render(view: view, model: model)
    }

    def saveRegistration () {
        String message;
        customerService.clearCustomerSession(session);
        def registrationConfigs = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_REGISTRATION_SETTINGS)
        def captchaConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, "captcha_setting")
        if(registrationConfigs.registration_captcha.toBoolean() && captchaConfig == "enable" && !captchaService.validateCaptcha(params, request)) {
            message = g.message(code: "invalid.captcha.entry")
        } else {
            if( registrationConfigs.terms_active == "activated" && !params.registrationTerms) {
                message = g.message(code: 'agree.with.terms.and.conditions')
            } else {
                def customer;
                try {
                    customer = customerService.save(params)
                    if(customer) {
                        if(registrationConfigs.registration_status_type == DomainConstants.CUSTOMER_REG_TYPE.OPEN) {
                            Thread.start {
                                AppUtil.initialDummyRequest()
                                commanderMailService.sendCustomerRegistrationMail(customer.id)
                            }
                        }
                        if(registrationConfigs.registration_status_type == DomainConstants.CUSTOMER_REG_TYPE.AWAITING_APPROVAL) {
                            render(view: "/site/siteAutoPage", model: [name: DomainConstants.AUTO_GENERATED_PAGES.CUSTOMER_REGISTRATION,
                                    view: "/site/customerRegistrationAwaitingInfo.gsp", awaitingMessage: registrationConfigs.restricted_registration_message])
                        } else {
                            session.customer = customer.id
                            Cookie cookie = request.getCookies().find {it.name.startsWith("remember-customer")}
                            if(cookie) {
                                cookie.maxAge = 0;
                                response.addCookie(cookie);
                            }
                            if(params.referer) {
                                redirect(uri: params.referer);
                                return;
                            } else {
                                redirect(uri: "/customer/profile")
                            }
                        }
                        return;
                    } else {
                        message = g.message(code: 'unable.register.contact.vendor')
                    }
                } catch(ApplicationRuntimeException run) {
                    message = g.message(code: run.localizedMessage)
                }
            }
        }
        flash.model = [error: message]
        params.remove("controller")
        params.remove("action")
        flash.param = params
        redirect(uri: "/customer/register")
    }

    @AutoGeneratedPage("profile")
    @RequiresCustomer
    def profile() {
        String view = "/site/siteAutoPage"
        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_PROFILE_PAGE)
        def customWelcomeHtml = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_PROFILE_PAGE, "page_html")
        def isWelcomeMessageActive = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.CUSTOMER_PROFILE_PAGE, "welcome_message_active")
        if(customWelcomeHtml){
            customWelcomeHtml= configService.macroReplace(customWelcomeHtml,session.customer)
        }
        viewConfig.enableWallet = paymentGatewayService.enableWalletPayment
        Map model = [name : DomainConstants.AUTO_GENERATED_PAGES.CUSTOMER_PROFILE, customer: Customer.get(session.customer),
                     storeName: StoreDetail.first()?.name ?: "", viewConfig: viewConfig, customWelcomeHtml: customWelcomeHtml,
                     isWelcomeMessageActive: isWelcomeMessageActive, view: "/site/autopage/customerProfile/profile.gsp"]
        view = HookManager.hook("auto-page-view-model", view, model)
        render(view: view, model: model)
    }

    @RequiresCustomer
    def loadOverview() {
        Customer customer = Customer.load(session.customer)
        render(view: "/site/autopage/customerProfile/overview", model: [:])
    }

    @RequiresCustomer
    def loadAvailablePage() {
        List<Page> pages = pageService.filterAvailablePage([customerId: session.customer, excludeOpen: true])
        render(view: "/site/autopage/customerProfile/availablePage", model: [pages: pages])
    }

    @RequiresCustomer
    def loadManageAccount() {
        Customer customer = Customer.get(session.customer)
        Address address = customer.address
        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.MANAGE_MY_ACCOUNT)
        viewConfig.enableWallet = paymentGatewayService.enableWalletPayment
        render(view: "/site/autopage/customerProfile/manageAccount", model: [address: address, billingAddresses: customer.billingAddresses,
                activeBillingAddress: customer.activeBillingAddress, shippingAddresses: customer.shippingAddresses,
                activeShippingAddress: customer.activeShippingAddress, message: "", viewConfig: viewConfig])
    }

    def loadMyCarts() {
        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.MY_CARTS)
        render(view: "/site/autopage/customerProfile/myCarts", model: [viewConfig: viewConfig])
    }

    def loadMyLists() {
        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.MY_LISTS)
        render(view: "/site/autopage/customerProfile/myLists", model: [viewConfig: viewConfig])
    }

    def loadMyEntitlements() {
        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.MY_ENTITLEMENTS)
        render(view: "/site/autopage/customerProfile/myEntitlements", model: [viewConfig: viewConfig])
    }

    @RequiresCustomer
    def loadOrdersView() {
        Customer customer = Customer.get(session.customer)

        Collection<Order> pendingOrders = []
        Order.createCriteria().list {
            eq("customerId", customer.id)
        }.each {
            it.orderStatus.equals(DomainConstants.ORDER_STATUS.PENDING) ? pendingOrders.add(it) : ""
        }
        Map<Order, Double> pendingOrderTotals = [:]
        pendingOrders.each {
            pendingOrderTotals[it] = it.grandTotal
        }.sort { -it.id }


        Collection<Order> completedOrders = Order.createCriteria().list {
            eq("customerId", customer.id)
            eq "orderStatus", DomainConstants.ORDER_STATUS.COMPLETED
        }
        Map<Order, Double> completedOrderTotals = [:]
        completedOrders.each {
            completedOrderTotals[it] = it.grandTotal
        }.sort { -it.id }

        Map viewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.MY_ORDERS)

        render(view: "/site/autopage/customerProfile/myOrders", model: [
                viewConfig          : viewConfig,
                pendingOrders       : pendingOrders,
                pendingOrderTotals  : pendingOrderTotals,
                completedOrders     : completedOrders,
                completedOrderTotals: completedOrderTotals])
    }


    @RequiresCustomer
    def loadAccountDetails() {
        Customer customer = Customer.get(session.customer)
        render(view: "/site/autopage/customerProfile/accountInfoView", model: [address: customer.address])
    }

    @RequiresCustomer
    def editAccountDetails() {
        Customer customer = Customer.get(session.customer)
        Address address = customer.address
        def states = administrationService.getStatesForCountry(address.country.id)
        Map fieldsConfigs = (Map)AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES['CUSTOMER_ACCOUNT_INFORMATION'])
        List<String> sortedFields = configService.getSortedFields(fieldsConfigs)
        List<String> activeFields = configService.getActiveFields(sortedFields, fieldsConfigs)
        render(view: "/site/autopage/customerProfile/accountInfoEdit", model: [address: address, states: states,sortedFields: sortedFields,fields: activeFields,fieldsConfigs: fieldsConfigs ])
    }

    @RequiresCustomer
    def updateAccountDetails() {
        Customer customer = Customer.get(session.customer)
        Address address = customer.address
        if(customerService.updateAccountDetails(customer, params)) {
            render(view: "/site/autopage/customerProfile/accountInfoView", model: [address: address, status: "success", message: g.message(code: "account.update.successful")])
        } else {
            def states = administrationService.getStatesForCountry(address.country.id)
            render(view: "/site/autopage/customerProfile/accountInfoEdit", model: [address: customer.address, states: states,
                status: "error", message: g.message(code: "account.update.failed")])
        }
    }

    @RequiresCustomer
    def editPassword() {
        render(view: "/site/autopage/customerProfile/editPassword", model: [])
    }

    @RequiresCustomer
    def updatePassword() {
        Customer customer = Customer.get(session.customer)
        String curPass = params.currentPassword
        String newPass= params.newPassword
        String curPass1 = curPass.encodeAsMD5()
        String curPass2 = customer.password
        if(curPass1.equals(curPass2)) {
            if(customerService.updatePassword(customer.id, newPass)) {
                render([status: "success", message: g.message(code: "password.change.success")] as JSON)
                return;
            }
        } else {
            render([status: "error", message: g.message(code: "current.password.not.match")] as JSON)
            return;
        }
        render([status: "error", message: g.message(code: "password.update.failed")] as JSON)
    }

    @RequiresCustomer
    def loadAddressList() {
        boolean isBilling = params.addressType != "shipping"
        Customer customer = Customer.get(session.customer)
        List<Address> addresses = isBilling ? customer.billingAddresses : customer.shippingAddresses
        Address activeAddress = isBilling ? customer.activeBillingAddress : customer.activeShippingAddress
        render(view: "/site/autopage/customerProfile/addressListView", model: [addresses: addresses, activeAddress: activeAddress])
    }

    @RequiresCustomer
    def editAddress() {
        boolean isBilling = params.addressType != "shipping"
        Address address = params.addressId ? Address.get(params.addressId.toLong(0)) : new Address()
        Country country = address.country ?: Country.get(AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.GENERAL, 'default_country').toLong(0))
        def states = administrationService.getStatesForCountry(country.id)
        Map fieldsConfigs = (Map)AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES[isBilling ? "BILLING_ADDRESS_FIELD" : "SHIPPING_ADDRESS_FIELD"])
        List<String> sortedFields = configService.getSortedFields(fieldsConfigs)
        List<String> activeFields = configService.getActiveFields(sortedFields, fieldsConfigs)
        render(view: "/site/autopage/customerProfile/editAddress", model: [fields: activeFields, fieldsConfigs: fieldsConfigs,
            address: address, country: country, states: states, action: "saveAddress", addressType: isBilling ? "billing" : "shipping"])
    }

    @RequiresCustomer
    def saveAddress() {
        boolean isBilling = params.addressType != "shipping"
        Customer customer = Customer.get(session.customer)
        if(customerService.saveAddress(customer, params)) {
            Long id = params.id.toLong(0);
            String effectiveAddress = isBilling ? "effective_billing_address" : "effective_shipping_address"
            if(id == session[effectiveAddress]?.id) {
                AppEventManager.fire(isBilling ? "effective-billing-change" : "effective-shipping-change", [session.id])
            }
            session.effective_billing_address = new AddressData(customer.activeBillingAddress)
            render([status: "success", message: g.message(code: "address.save.success")] as JSON)
        } else {
            render([status: "error", message: g.message(code: "address.save.failed")] as JSON)
        }
    }

    @RequiresCustomer
    def deleteAddress() {
        boolean isBilling = params.addressType != "shipping"
        Customer customer = Customer.get(session.customer)
        Long addressId = params.id ? params.id.toLong(0) : 0
        Address address = isBilling ? customer.activeBillingAddress : customer.activeShippingAddress
        if(address.id == addressId) {
            render([status: "error", message: g.message(code: "active.address.cannot.delete")] as JSON)
        } else {
            if(addressId > 0 && customerService.deleteAddress(customer, addressId, isBilling)) {
                render([status: "success", message: g.message(code: "address.delete.success")] as JSON)
            } else {
                render([status: "error", message: g.message(code: "address.delete.failed")] as JSON)
            }
        }
    }

    @RequiresCustomer
    def changeActiveAddress() {
        boolean isBilling = params.addressType != "shipping"
        Customer customer = Customer.get(session.customer)
        Long addressId = params.id ? params.id.toLong(0) : 0
        if(addressId > 0 && customerService.changeActiveAddress(customer, addressId, isBilling)) {
            String effectivAddress = isBilling ? "effective_billing_address" : "effective_shipping_address"
            if(session[effectivAddress]) {
                session[effectivAddress] = new AddressData(Address.proxy(addressId))
                AppEventManager.fire(isBilling ? "effective-billing-change" : "effective-shipping-change", [session.id])
            }
            render([status: "success", message: g.message(code: "active.address.change.success")] as JSON)
        } else {
            render([status: "error", message: g.message(code: "active.address.change.failed")] as JSON)
        }
    }

    @RequiresCustomer
    def loadPendingOrder() {
        Customer customer = Customer.get(session.customer)
        Collection<Order> orders = []
        Order.createCriteria().list {
            eq("customerId", customer.id)
        }.each {
            it.orderStatus.equals(DomainConstants.ORDER_STATUS.PENDING) ? orders.add(it) : ""
        }
        Map<Order, Double> orderTotals = [:]
        orders.each {
            orderTotals[it] = it.grandTotal
        }.sort {-it.id}
        render(view: "/site/autopage/customerProfile/pendingOrder/orderListView", model: [orders: orders, orderTotals: orderTotals])
    }

    @RequiresCustomer
    def loadPendingOrderDetails() {
        Customer customer = Customer.get(session.customer)
        Long orderId = params.orderId ? params.orderId.toLong(0) : 0
        Order order = Order.get(orderId)
        Collection<Order> allOrders = Order.createCriteria().list {
            eq("customerId", customer.id)
        }
        if(allOrders.contains(order) && order.orderStatus.equals(DomainConstants.ORDER_STATUS.PENDING)) {
            Map<OrderItem, Double> itemTotals = [:]
            order.items.each {
                itemTotals[it] = it.getTotalAmount()
            }
            render(view: "/site/autopage/customerProfile/pendingOrder/orderDetailsView", model: [order: order, itemTotals: itemTotals])
        }
    }

    @RequiresCustomer
    def loadCompletedOrder() {
        Customer customer = Customer.get(session.customer)
        Collection<Order> orders = Order.createCriteria().list {
            eq("customerId", customer.id)
            eq "orderStatus", DomainConstants.ORDER_STATUS.COMPLETED
        }
        Map<Order, Double> orderTotals = [:]
        orders.each {
            orderTotals[it] = it.grandTotal
        }.sort {-it.id}
        render(view: "/site/autopage/customerProfile/completedOrder/orderListView", model: [orders: orders, orderTotals: orderTotals])
    }

    @RequiresCustomer
    def loadCompletedOrderDetails() {
        Customer customer = Customer.get(session.customer)
        Long orderId = params.orderId ? params.orderId.toLong(0) : 0
        Order order = Order.get(orderId)
        Collection<Order> allOrders = Order.createCriteria().list {
            eq("customerId", customer.id)
        }
        if(allOrders.contains(order) && order.orderStatus.equals(DomainConstants.ORDER_STATUS.COMPLETED)) {
            Map<OrderItem, Double> itemTotals = [:]
            order.items.each {
                itemTotals[it] = it.getTotalAmount()
            }
            render(view: "/site/autopage/customerProfile/completedOrder/orderDetailsView", model: [order: order, itemTotals: itemTotals])
        }
    }

    @RequiresCustomer
    def loadStoreCredit() {
        Customer customer = Customer.get(session.customer)
        render(view: "/site/autopage/customerProfile/storeCredit", model: [storeCredit: customer.storeCredit])
    }

    @RequiresCustomer
    def sendStoreCreditRequest() {
        Customer customer = Customer.get(session.customer)
        String msg = params.msg
        if(customerService.sendStoreCreditRequestMail(customer, msg)) {
            render([status: "success", message: g.message(code: "store.credit.request.send")] as JSON)
        } else {
            render([status: "error", message: g.message(code: "store.credit.request.send.fail")] as JSON)
        }
    }

    @RequiresCustomer
    def loadOrderComments() {
        Long orderId = params.orderId ? params.orderId.toLong(0) : 0
        Order order = Order.get(orderId)
        StoreDetail storeDetail = StoreDetail.first()
        List<OrderComment> comments = OrderComment.findAllByOrderAndIsVisibleToCustomer(order, true)
        render(view: "/site/autopage/customerProfile/orderCommentView", model: [order: order, comments: comments, storeDetail: storeDetail])
    }

    @RequiresCustomer
    def sendCustomerComment() {
        Order order = Order.get(params.orderId.toLong(0))
        params.message = params.message.trim()
        try {
            OrderComment comment = customerService.sendOderComment(order, params)
            render([status: "success", message: params.message.encodeAsBMHTML(), customerName: order.customerName, date: comment.created.toSiteFormat(true, false, session.timezone)] as JSON)
        } catch (Exception ex) {
            ex.printStackTrace()
            render([status: "error", message: g.message(code: "send.comment.fail")] as JSON)
        }

    }

    @RequiresCustomer
    def cancelOrder() {
        Order order = Order.get(params.orderId.toLong(0))
        if(order.customerId == AppUtil.loggedCustomer && order.orderStatus != DomainConstants.ORDER_STATUS.COMPLETED && order.paymentStatus != DomainConstants.ORDER_PAYMENT_STATUS.PAID && order.shippingStatus == DomainConstants.SHIPPING_STATUS.AWAITING) {
            def result = orderService.changeOrderStatus([id: order.id, status: DomainConstants.ORDER_STATUS.CANCELLED])
            if(result) {
                render([status: "success", message: g.message(code: "order.cancelled.success")] as JSON)
            } else {
                render([status: "error", message: g.message(code: "order.cancelled.failure")] as JSON)
            }
        }
    }

    @RequiresCustomer
    def payOrder() {
        Order order = Order.get(params.orderId.toLong(0))
        if(order.customerId == AppUtil.loggedCustomer && order.orderStatus != DomainConstants.ORDER_STATUS.COMPLETED && order.paymentStatus != DomainConstants.ORDER_PAYMENT_STATUS.PAID && order.shippingStatus == DomainConstants.SHIPPING_STATUS.AWAITING) {
            List<Map> exceptions = CartManager.addToCart(order.items)
            Cart cart = CartManager.getCart(session.id)
            if(exceptions.size() == 0) {
                cart.orderId = order.id
                render([status: "success"] as JSON)
            } else if(exceptions.size() < order.items.size()) {
                cart.orderId = order.id
                String popup = g.include(view: "/site/cart/cartItemableAddExceptionPopup.gsp", model: [exceptions: exceptions, totalItems: order.items.size()]).toString()
                render([status: "partial", content: popup] as JSON)
            } else {
                render([status: "error", message: g.message(code: "pending.order.add.to.cart.fail")] as JSON)
            }
        }
    }

    def showShareOption() {
        render(view: "/site/customerCompletedOrderShareOption")
    }

    def generateSocialMediaShareKey() {
        String productId = params.productId
        String customerId = params.customerId
        String medium = params.medium
        String finalString = "${productId},${customerId},${medium}"
        InformationEncrypter encrypter = new InformationEncrypter()
        encrypter.hiddenInfos.add(finalString)
        Product product = Product.load(productId)
        String url = "product/" + product.url + "?shareid=" + encrypter.toString()
        render([status: "success", url: url] as JSON)
    }

    @RequiresCustomer
    def addAllToCart() {
        Order order = Order.load(params.id)
        List<OrderItem> orderItems = params.itemId ? [OrderItem.load(params.itemId)] : order.items
        if(order.customerId == AppUtil.loggedCustomer && order.orderStatus == DomainConstants.ORDER_STATUS.COMPLETED) {
            List<Map> exceptions = CartManager.addToCart(orderItems)
            if(exceptions.size() == 0) {
                render([status: "success"] as JSON)
            } else if(exceptions.size() < order.items.size()) {
                String popup = g.include(view: "/site/cart/cartItemableAddExceptionPopup.gsp", model: [exceptions: exceptions, totalItems: order.items.size()]).toString()
                render([status: "partial", ex: popup] as JSON)
            } else {
                render([status: "error", message: g.message(code: (params.itemId ? "add.to.cart.fail" : "add.all.to.cart.failed"))] as JSON)
            }
        }
    }

    @RequiresCustomer
    def loadSpecialProduct() {
        Map model = [:]
        model.overViewConfig = AppUtil.getConfig(DomainConstants.SITE_CONFIG_TYPES.OVERVIEW)
        model.config = [
                "display-type": NamedConstants.PRODUCT_WIDGET_VIEW.SCROLLABLE,
                "show-pagination": "none",
                item_per_page: 10,
                price: "true",
                description: "false",
                label_for_call_for_price: "s:call.for.price",
                product_listing_id: "customer-page-product-listing",
                show_on_hover: model.overViewConfig["show_on_hover"]
        ]
        model.overViewConfig.each {
            if(it.key.startsWith("add_to_")) {
                model.config[it.key] = it.value
            }
        }

        model.topSelling = productService.getSpecialProduct([type: "topSelling", max: model.overViewConfig.max_top_selling_product.toInteger(0)])
        model.featured = productService.getSpecialProduct([type: "featured", max: model.overViewConfig.max_featured_product.toInteger(0)])
        model.onSale = productService.getSpecialProduct([type: "onSale", max: model.overViewConfig.max_onsale_product.toInteger(0)])
        model.newProduct = productService.getSpecialProduct([type: "new", max: model.overViewConfig.max_new_product.toInteger(0)])
        model.lastViewed = productService.getSpecialProduct([type: "lastViewed", max: model.overViewConfig.max_last_viewed_product.toInteger(0)])
        model.lastBought = productService.getSpecialProduct([type: "lastBought",
                           max: model.overViewConfig.max_last_bought_product.toInteger(0), customerId: AppUtil.loggedCustomer])
        render(view: "/site/autopage/customerProfile/specialProducts", model: model)
    }

    @RequiresCustomer
    def loadStoreWallet() {
        Customer customer = Customer.load(AppUtil.loggedCustomer)
        List<CreditCard> cards = paymentGatewayService.getAvailableCreditCard([
            customerId   : customer.id
        ])
        render(view: "/site/autopage/customerProfile/walletView", model: [cards: cards])
    }

    @RequiresCustomer
    def addCreditCard() {
        CreditCard card = params.id ? CreditCard.load(params.id) : new CreditCard()
        if(!card.id) {
            card.discard()
        }
        Map creditCardConfig = [:]
        PaymentGatewayMeta.findAllByFieldFor(DomainConstants.PAYMENT_GATEWAY_CODE.CREDIT_CARD).each {
            creditCardConfig[it.name] = it.value
        }
        render(view: "/site/autopage/customerProfile/linkCardView", model: [card: card, creditCardConfig: creditCardConfig])
    }

    @RequiresCustomer
    def saveCreditCard() {
        try {
            paymentGatewayService.saveCreditCard(params)
            render([status: "success", message: g.message(code: "link.card.success")] as JSON)
        } catch (ApplicationRuntimeException ex) {
            ex.printStackTrace()
            render([status: "error", message: g.message(code: ex.message)] as JSON)
        } catch (Exception ex) {
            ex.printStackTrace()
            render([status: "error", message: g.message(code: "link.card.error")] as JSON)
        }
    }

    @RequiresCustomer
    def removeCreditCard() {
        paymentGatewayService.removeCreditCard(params)
        render([status: "success", message: g.message(code: "remove.success", args: [g.message(code: "credit.card")])] as JSON)
    }

}